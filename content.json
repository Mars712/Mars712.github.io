{"meta":{"title":"Mars'blog","subtitle":"","description":"这是Mars的博客","author":"Mars","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-01-25T08:07:02.790Z","updated":"2025-01-25T08:07:02.790Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有标签","date":"2025-01-25T08:08:28.625Z","updated":"2025-01-25T08:08:28.625Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-01-25T08:07:51.765Z","updated":"2025-01-25T08:07:51.765Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2025-01-25T08:08:12.439Z","updated":"2025-01-25T08:08:12.439Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"}],"posts":[{"title":"bfs and dfs and 并查集 板子","slug":"bfs-dfs-并查集板子","date":"2025-02-23T15:26:34.000Z","updated":"2025-03-29T12:34:57.021Z","comments":true,"path":"2025/02/23/bfs-dfs-并查集板子/","permalink":"http://example.com/2025/02/23/bfs-dfs-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%9D%BF%E5%AD%90/","excerpt":"","text":"dfs 走迷宫 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;int mp[110][110],vis[110][110];int bx,by,ex,ey;int dx[4]=&#123;0,0,-1,1&#125;,dy[4]=&#123;-1,1,0,0&#125;;bool flag=false;int n;bool check(int nx,int ny)&#123; if(nx&gt;=1&amp;&amp;nx&lt;=n&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=n&amp;&amp;vis[nx][ny]==false&amp;&amp;mp[nx][ny]==0)&#123;//能在迷宫中走就行 return true; &#125; return false;&#125;void dfs(int x,int y)&#123; if(vis[x][y])return;//已走过，返回,表示没有路了 if(x==ex&amp;&amp;y==ey)&#123;//走到终点 flag=true; return; &#125; vis[x][y]=true;//标记以走过的点 for(int i=0;i&lt;4;i++)&#123; int nx=x+dx[i]; int ny=y+dy[i]; if(check(nx,ny))dfs(nx,ny);//找到通路，下一步&#125;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;mp[i][j]; &#125; &#125; cin&gt;&gt;bx&gt;&gt;by&gt;&gt;ex&gt;&gt;ey; if(mp[bx][by]==1)&#123; cout&lt;&lt;&quot;NO&quot;; return 0; &#125; dfs(bx,by); if(flag)cout&lt;&lt;&quot;YES&quot;; else cout&lt;&lt;&quot;NO&quot;; return 0;&#125; bfs 最短路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//bfs#include&lt;bits/stdc++.h&gt;using namespace std;int dx[4]=&#123;0,0,-1,1&#125;,dy[4]=&#123;-1,1,0,0&#125;;char mp[50][50];int vis[50][50];struct node&#123; int x,y,w;&#125;;int n,m;bool check(int nx,int ny)&#123; if(nx&gt;=1&amp;&amp;nx&lt;=m&amp;&amp;ny&gt;=1&amp;&amp;ny&lt;=n&amp;&amp;vis[nx][ny]==false&amp;&amp;mp[nx][ny]==&#x27;.&#x27;)return true; return false;&#125;int bfs(int bx,int by,int bw)&#123; queue&lt;node&gt;q; q.push(&#123;bx,by,bw&#125;); while(!q.empty())&#123; node p=q.front(); q.pop(); if(p.x==m&amp;&amp;p.y==n)return p.w; if (vis[p.x][p.y]) continue; vis[p.x][p.y]=true; int nx,ny; for(int i=0;i&lt;4;i++)&#123; nx=p.x+dx[i]; ny=p.y+dy[i]; if(check(nx,ny))q.push(&#123;nx,ny,p.w+1&#125;); &#125; &#125; return -1;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; cin&gt;&gt;mp[i][j]; &#125; &#125; cout&lt;&lt;bfs(1,1,1); return 0;&#125; 并查集 找祖先 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int fa[200010];//find()是找祖先的过程int find(int x)&#123; if(fa[x]==x)return x; else &#123; fa[x]=fa[find(fa[x])];//递归 return fa[x]; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++)fa[i]=i; int m; cin&gt;&gt;m; while(m--)&#123; int z,x,y; cin&gt;&gt;z&gt;&gt;x&gt;&gt;y; if(z==1)fa[find(x)]=find(y); else &#123; if(find(x)==find(y))cout&lt;&lt;&quot;Y&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;N&quot;&lt;&lt;endl; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"初等数论","slug":"初等数论","date":"2025-02-19T12:19:35.000Z","updated":"2025-02-23T08:57:42.924Z","comments":true,"path":"2025/02/19/初等数论/","permalink":"http://example.com/2025/02/19/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/","excerpt":"","text":"1.整除 a|b 表示b能被a整除。 2.模运算 在处理大数取模运算中运用 以下图片为相关概述： 以下图片为注意事项： 3.快速幂 处理幂次方时可降低时间复杂度 1.递归写法： 快速幂可以取模运算，对下列代码而言，每次ans*a都取模mod m 递归代码： 2.位运算写法： 位运算代码： 解释代码： ans为幂次方结果，先维护一个a,当移位时将a*a,确保幂次方模拟正确，通过n&amp;1判断最后一位是否为1， 若为1将ans*a得到最新幂次方结果，并维护a,移位；若不为1，则继续维护a,移位。直至n的二进制位次移动完。 4.二进制转化 解释代码： mask为移位标志符，让1左移31位使得最高位为1的32为2进制数，随后让number&amp;mask查看最高位，输出最高位，至mask移动32位结束为止。 5.GCD 概述：1.__gcd()函数可直接调用求gcd,但时间复杂度大于辗转相除法。 2.性质：gcd(a,b)&lt;&#x3D;min(a,b),具体样例见牛客周赛76的c题 链接：[小红的gcd][https://ac.nowcoder.com/acm/contest/99990/C] 3.更相减损法可重复贡献，如gcd(a,b,c)&#x3D;gcd(a,b-a,c-a) 4.对于gcd(a,0)&#x3D;a,可把0看为基元，效果相当于加法初始量0，乘法初始量1 6.类欧几里得算法经典例题 给两个有理数a,b,求最小正整数k,使得[ak,bk]里有整数 算法概述 7.扩展欧几里得算法(exgcd) 裴蜀定理：设a,b是不全为0的整数，则存在整数x,y,使得ax+by&#x3D;gcd(a,b) 换句话说，就是二元一次方程ax+by&#x3D;(a,b)有整数解 考虑解一个二元一次不定方程：ax+by&#x3D;c(a,b,c为整数且a,b都不为0) 定理1：设它有整数解x&#x3D;x0,y&#x3D;y0,则一切整数解可以写成x&#x3D;x0-b1t,y&#x3D;y0-a1t;(t&#x3D;0,1,-1,2,-2,…) where a1&#x3D;a&#x2F;gcd(a,b),b1&#x3D;b&#x2F;gcd(a,b). 定理2：一般式有整数解的充要条件是gcd(a,b)|c;因此：给出ax+by&#x3D;c,只要gcd(a,b)|c,找到了一组特解，就能用定理1找到所有整数解 ​ 找特解方法： 1.概述： 2.实现代码： 解释：对于 ​ int tmp&#x3D;x;x&#x3D;y.y&#x3D;tmp-a&#x2F;b*y; 由关系x1&#x3D;y2,y1&#x3D;x2-a&#x2F;b*y2,我们首先要用一个tmp维护一个x2,防止x2被赋值为y2,其次我们由递归回溯的性质，实现关系方程(及x&#x3D;y这一步,x本为x2,y本为y2,将y2的值赋给x2成为x1,此时我们用tmp维护了x2,实现关系方程2) 8.同余与逆元1.同余 性质三:d是a,b的因子，若d,m互质，则a1&#x3D;a&#x2F;d,b1&#x3D;b&#x2F;d也是同余 a的逆元为xmodm 2.逆元 3.费马小定理 1.划线部分可改为a^(p-1)☰1(modp) (同余性质3推出) 2.ax☰1(modm),x为a的逆元，则a^(p-2)modp是a的一个逆元 9.唯一分解定理 代码块 1.方法一： 123456789101112int fac[maxn],power[maxn];cnt=0;//唯一分解定理void getprimefactor(int n)&#123; for(int i=2;i&lt;=n;i++)&#123; fac[cnt++]=i; while(n%i==0)&#123; n/=i; power[cnt]++; &#125; &#125;&#125; fac是因子，power是幂次 2.方法二： 12345678910void getprimefactor2(int n)&#123; for(int i=1;i&lt;=cnt&amp;&amp;pri[i]&lt;=sqrt(n);i++)&#123; fac[cnt2++]=i; while(n%pri[i]==0)&#123; n/=pri[i]; power[cnt2]++; &#125; &#125; if(n&gt;1)fac[cnt2++]=n,power[cnt2]=1;//因数为本身时特判断，如29，因数只有29&#125; 1.pri[cnt]为质数数组,cnt为数组元素个数 2.如果最后余下的数不为1，说明这个因子是本身，特判 3.此法较法一复杂度小，时间复杂度o(sqrt(n))","categories":[],"tags":[]},{"title":"我的第一篇博客","slug":"我的第一篇博客","date":"2025-01-25T06:18:01.000Z","updated":"2025-02-19T13:43:53.728Z","comments":true,"path":"2025/01/25/我的第一篇博客/","permalink":"http://example.com/2025/01/25/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"成功完成了博客的搭建。后续我会将所学的一些笔记放在博客上，供自己复习和大家观光。 来我博客参观的朋友们： 欢迎你们！！！","categories":[],"tags":[]}],"categories":[],"tags":[]}